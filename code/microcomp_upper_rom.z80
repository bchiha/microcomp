; Microcomp Upper ROM
; -------------------
;
; Compiled and partially written by Brian Chiha
;
; This listing containts the full 2k upper ROM component of the Microcomp.
; It contains a menu driver to select the programs on the ROM.  It includes
; the following programs.  Some are standalone programs in the TE Magazines,
; and some are unpublished found in binaries or written by me.
;
; Black Jack - Published Issue 14
; Master Mind - Unpublished RAMless re-write by me
; NIM - Unpublished, slightly modified by me
; Tug O War - Published Issue 14
; Output Demo - Written by me
;
; The Menu driver written by me at 0x0000 removes the need to select the program
; via the DIP Switches.  Simply select the program from the visual Menu.  Press
; Reset to restart the Menu.
;
; For further details regarding the code, please see specific program files
;
;Constants
BTN_A:      EQU     80H            ;Button 'A' 
BTN_B:      EQU     40H            ;Button 'B'
BTN_BOTH:   EQU     BTN_A + BTN_B  ;Button 'A' and 'B' 

            ORG     0000H

; -----------
; MENU DRIVER
; -----------
;

MENU_START:
            ;Start of menu routine
            LD      A,(MENU_CONFIG) ;Load A with total menu items
            LD      I,A             ;Set I with total menu items
            LD      C,00H           ;Current menu item
            LD      IY,BTN_HANDLE   ;Set IY to handle button press from menu
            LD      IX,MENU         ;Set IX to menu loop
MENU:
            ;Menu display loop
            LD      HL,(MENU_CONFIG + 1) ;Load HL wtth Menu Text table
            LD      A,C             ;Set A to current menu item
            OR      A               ;Is it zero?, skip indexing
            JR      Z,DOSCROLL      ;Just do the scroll
            LD      B,A             ;Set A to B counter
MENUIND:
            ;Find the next menu text by searching for end of line 0FFH
            LD      A,(HL)          ;Load A contents at HL
            INC     HL              ;Increment HL
            INC     A               ;Is it FF, then result will be zero
            JR      Z,MENUNEXT      ;Skip increment
            JR      MENUIND         ;Check next menu item
MENUNEXT:
            DJNZ    MENUIND         ;Jump back 3 to Increment HL and repeat menu indexing
            ;Menu found
DOSCROLL:
            JR      SEGSCROLL       ;Call Seven Segment Scroll routine
                                    ;Can only exit from button press
BTN_HANDLE:
            ;Button Handler, A is the current button pressed
            LD      B,A             ;Save button pressed
BTNLOOP:
            ;Ensure button is released
            IN      A,(01)          ;Read input latch
            OR      A               ;Is button A still pressed?
            JR      NZ,BTNLOOP      ;Yes, loop until released
            LD      A,B             ;Restore button pressed
            CP      BTN_B           ;Has button B been pressed?
            JR      Z,MENUSEL       ;Yes, Jump to menu selection
            ;Must be button 'A' if here. Go to next menu item
            INC     C               ;Move to next menu item
            LD      A,I             ;Load A with total menu items
            SUB     C               ;Subtract current menu item from total
            JR      Z,MENU_START    ;On last menu item, re-run from start
            JR      MENU            ;Display menu loop

MENUSEL:
            ;Button 'B' pressed, jump to the procedure based on the menu selected
            LD      HL,(MENU_CONFIG + 3) ;Load HL wtth Menu Jump table
            LD      A,C             ;Set A to current menu item
            OR      A               ;No indexing needed
            JR      Z,RUNPROC       ;Jump to procedure
PROCIND:
            INC     HL              ;Move to next jump
            INC     HL              ;Move to next jump
            INC     HL              ;Move to next jump
            DEC     A               ;Decrease menu index
            JR      NZ,PROCIND      ;Move to next index
RUNPROC:
            JP      (HL)            ;Jump to the menu 
            
;Scrolling Seven Segment text.  
; IN - HL - data to send, FF to end.  Must have atleast one character to print.
; Exit to address pointing to IX
SEGSCROLL:
            LD      B,80H           ;Half Delay
SEGLOOP:
            ;Display on both segments
            LD      A,(HL)          ;Load Segment data
            SET     7,A             ;Set bit 7 to display on LH LED Segment
            OUT     (02),A          ;Output to LH segment
            INC     HL              ;Move to next value
            LD      A,(HL)          ;Load Segment data
            CP      0FFH            ;Is it end of sequence
            JR      Z,ENDSRL        ;Yes, Exit the routine
            OUT     (02),A          ;Output to RH segment
            DEC     HL              ;Move back to first value
            DJNZ    SEGLOOP         ;Repeat FF times
            ;Check for key press
            IN      A,(01)          ;Read input latch
            AND     BTN_A + BTN_B   ;Has button A or B been pressed?
            JR      Z,SEGNEXT       ;No, Keep looping display
            JP      (IY)            ;Jump to button handler
SEGNEXT:     
            INC     HL              ;Move to next data value
            JR      SEGSCROLL       ;Repeat until FF is found
ENDSRL:     
            JP      (IX)            ;Jump back to calling routine

;---------------------------------------------------
; END OF MENU DRIVER. MAKE YOUR CONFIGURATIONS BELOW
;---------------------------------------------------

;Must have configuration. Modify to suit
MENU_CONFIG:
            DB      05H         ;Number of menu items
            DW      MENU_TEXT   ;Jump table for menu text on seven segment
            DW      MENU_JUMP   ;Jump table for menu items

MENU_TEXT:
            DB      7CH,38H,77H,39H,75H,1EH,77H,39H,75H,00H,00H,0FFH ;Blackjack
            DB      55H,77H,6DH,70H,79H,33H,55H,06H,37H,5EH,00H,00H,0FFH ;Mastermind
            DB      37H,06H,55H,00H,00H,0FFH ;NIM    
            DB      70H,3EH,3DH,00H,3FH,1DH,77H,33H,00H,00H,0FFH ;Tug O War
            DB      38H,79H,5EH,00H,5EH,79H,55H,3FH,00H,00H,0FFH ;Led Demo

MENU_JUMP:
            JP      BLACKJACK
            JP      MASTERMIND
            JP      NIM
            JP      TUGOWAR
            JP      LEDDEMO

;-----------
; Black Jack
;-----------
BLACKJACK:
            ;Set up
            XOR     A          ;Zero registers A,I,E and C
            LD      I,A        ;I Register used to detect 2nd push of button
            LD      E,A        ;E Register used to keep the tally of 21
            LD      C,A        ;C Register used to test if ACE card is present
            LD      IX,CARDS   ;Load IX with start of Cards Table
BJ_GAME:
            ;Start of game loop            
            IN      A,(01)     ;Read Input Latch
            CP      BTN_B      ;Is button 'B' still pressed?
            JR      Z,BLACKJACK ;Yes, go back to start to prevent cheating!
CRD_SEL:
            ;Cycle through cards quickly, wait for button 'B' press
            LD      IY,CARDS+3 ;No, Point IY to start of real Cards table 
            LD      H,0DH      ;store H with number of Cards in Card table
NXT_CRD:
            ;Display one card at a time
            LD      A,(IX+0)   ;Load A with first byte of card table
            OUT     (02),A     ;Output to RH Display
            LD      B,08H      ;Load B with small delay
BJ_LOOP1:   DJNZ    BJ_LOOP1   ;Delay
            XOR     A          ;Zero A
            SET     7,A        ;Set bit 7 to output to LH display
            ADD     A,(IX+1)   ;Load A with second byte of card table
            OUT     (02),A     ;Output to LH Display
            IN      A,(01)     ;Read Input Latch
            CP      BTN_B      ;Has button 'B' been pressed?
            JR      Z,SELECT   ;Yes, jump to handle button press
            LD      B,04H      ;Load B with small delay
BJ_LOOP2:   DJNZ    BJ_LOOP2   ;Delay
            INC     IY         ;Increase IY
            INC     IY         ;To move to 
            INC     IY         ;Next card
            DEC     H          ;Decrease card count
            JR      NZ,NXT_CRD ;If H isn't zero, jump to display next card
            JR      CRD_SEL    ;Repeat card selection routine
SELECT:         
            ;Card has been selected, display it.
            LD      D,60H      ;Display selected carf for 96 cycles
BJ_DISPLAY:
            LD      A,(IY+0)   ;Load A with first byte of card table
            OUT     (02),A     ;Output to RH Display
            LD      B,10H      ;Load B with small delay
BJ_LOOP3:   DJNZ    BJ_LOOP3   ;Delay
            XOR     A          ;Zero A
            SET     7,A        ;Set bit 7 to output to LH display
            ADD     A,(IY+1)   ;Load A with second byte of card table
            OUT     (02),A     ;Output to LH Display
            LD      B,10H      ;Load B with small delay
BJ_LOOP4:   DJNZ    BJ_LOOP4   ;Delay
            DEC     D          ;Decrease counter
            JR      NZ,BJ_DISPLAY ;Repeat display selected card

            ;Add selected card to total count, using software based DAA!!
            ;This is a really crappy way to do it.  Just use DAA
            LD      A,(IY+2)   ;Load A with numeric value of selected card
BJ_LOOP5:
            INC     E          ;Increase tally
            BIT     1,E        ;Is bit 1 and 3 set?
            JR      Z,NXT_VAL  ;If so, 
            BIT     3,E        ;Add 6 to roll over
            JR      Z,NXT_VAL  ;to next decimal number
            LD      B,06H      ;load B with 6
BJ_LOOP6:
            INC     E          ;Increase E
            DJNZ    BJ_LOOP6   ;Loop 6 times
NXT_VAL:
            DEC     A          ;Reduce card count for addition to E
            JR      NZ,BJ_LOOP5;Keep increasing count until A is zero

            ;Check if card is an ACE, and if one or two cards have been selected
            LD      A,(IY+0)   ;Load selected card character to A
            CP      77H        ;Is the card and "A"
            JR      NZ,NO_ACE  ;No, Skip updating C register
            SET     7,C        ;Set Bit 7 of C register to indicate an ACE card
NO_ACE:
            LD      A,I        ;Load Index Register into A
            INC     A          ;Update A for button press count
            LD      I,A        ;Save it back to index register
            CP      02H        ;Are there 2 button presses yet?            
            JR      NC,CHK_WIN ;Jump if second button pressed? 1-2 = carry set
            JR      BJ_GAME    ;Repeat Game to select second card
CHK_WIN:
            ;Blank display, Check to see if count is 21, if so flash '21',
            ;otherwise display current card total and keep getting more cards
            ;until bust
            LD      D,60H      ;Load D with timer for display
            XOR     A          ;Zero A
            OUT     (02),A     ;Blank the Display
            LD      B,0FFH     ;Load B with long delay
BJ_LOOP7:   DJNZ    BJ_LOOP7   ;Delay
CNT_DIS:
            LD      HL,NUMTBL  ;Load HL with start of 0-9 number table
            LD      A,E        ;Load total card count to A
            CP      21H        ;Is the total '21'
            JR      Z,BJ_WIN   ;Yes, Jump to Win game routine
            ;Display current card count
            AND     0FH        ;Mask out upper nibble of count
            ADD     A,L        ;Index A with start of number table
            LD      L,A        ;index L with character position
            LD      A,(HL)     ;Load A with segment number
            OUT     (02),A     ;Output A to Right Hand Segment
            LD      B,10H      ;Load B with short delay
BJ_LOOP8:   DJNZ    BJ_LOOP8   ;Delay
            LD      A,E        ;Reload A with card count
            RRA                ;Swap upper
            RRA                ;nibble with
            RRA                ;lower nibble
            RRA                ;
            AND     0FH        ;Mask out upper nibble of count    
            LD      HL,NUMTBL  ;Load HL with start of 0-9 number table
            ADD     A,L        ;Index A with start of number table
            LD      L,A        ;index L with character position
            LD      A,(HL)     ;Load A with segment number
            SET     7,A        ;Set Bit 7 to output on Left Hand display
            OUT     (02),A     ;Output A to Left Hand Segment
            LD      B,08H      ;Load B with short delay
BJ_LOOP9:   DJNZ    BJ_LOOP9   ;Delay
            DEC     D          ;Decrease Display counter
            JR      NZ,CNT_DIS ;Repeat card count display if D isn't zero
            ;Check if ACE card and count is over 22, adjust ACE to be 1 not 11
            LD      A,E        ;Load A with current card total
            CP      22H        ;Is it over 21?
            JR      NC,CHK_ACE ;Yes, check for ACE or bust
            JP      BJ_GAME    ;No, select another card
CHK_ACE:
            BIT     7,C        ;Has an ACE been selected?
            JR      Z,BUST     ;No, then over 21 and bust!
            SUB     10H        ;Yes, subtract 10 hex from total to make ACE=1
            LD      E,A        ;Save updated card tally to E
            RES     7,C        ;Reset ACE flag
            JR      CHK_WIN    ;Re display current total and continue
BUST:
            ;Game over.  Display a blank screen, wait and restart game
            XOR     A          ;Zero A
            OUT     (02),A     ;Blank the display
            LD      B,0FFH     ;Load B with long delay
BJ_LOOP10:  DJNZ    BJ_LOOP10  ;Long Delay
BJ_LOOP11:  DJNZ    BJ_LOOP11  ;Long Delay
BJ_LOOP12:  DJNZ    BJ_LOOP12  ;Long Delay
BJ_LOOP13:  DJNZ    BJ_LOOP13  ;Long Delay
            JP      BLACKJACK  ;Restart Game
BJ_WIN:
            ;Score equal 21, display 21 and flash it until button 'B' pressed
            LD      C,10H      ;Load C with flash delay
WIN_DIS:
            LD      A,06H      ;Load A with the characer '1'
            OUT     (02),A     ;Output a '1' to right hand display
            LD      B,10H      ;Load B with short delay
BJ_LOOP14:  DJNZ    BJ_LOOP14  ;Delay
            LD      A,0DBH     ;Load A with the character '2' for LH display
            OUT     (02),A     ;Output a '2' to left hand display
            LD      B,10H      ;Load B with short delay
BJ_LOOP15:  DJNZ    BJ_LOOP15  ;Delay
            DEC     C          ;Decrease flash counter
            JR      NZ,WIN_DIS ;Repeat '21' display if c isn't zero
            XOR     A          ;Zero A
            OUT     (02),A     ;Output a '1' to right hand display
            LD      B,0FFH     ;Load B with long delay
BJ_LOOP16:  DJNZ    BJ_LOOP16  ;Delay
            IN      A,(01)     ;Read input latch
            CP      BTN_B      ;Has Button 'B' been pressed?
            JP      Z,BLACKJACK ;Yes, Jump to start of game
            JR      BJ_WIN     ;No, keep displaying winning screen

            DB      00H,00H,00H,00H,00H,00H,00H  ;Fill

;Table that displays the numbers 0-9.  Numbers repeat more as they get closer to 9
NUMTBL:     DB      3FH,06H,5BH,4FH,66H,6DH,7DH,07H ;01234567
            DB      7FH,67H,00H,00H,00H,00H,00H,00H ;89

;Cards Table, the first two bytes produce the 'cards' on the display and the thrid
;byte is the numeric value.
CARDS:      DB      40H,40H,00H  ;'--' 0
            DB      5BH,00H,02H  ;'2_' 2
            DB      4FH,00H,03H  ;'3_' 3
            DB      66H,00H,04H  ;'4_' 4
            DB      6DH,00H,05H  ;'5_' 5
            DB      7DH,00H,06H  ;'6_' 6
            DB      07H,00H,07H  ;'7_' 7
            DB      7FH,00H,08H  ;'8_' 8
            DB      67H,00H,09H  ;'9_' 9
            DB      3FH,06H,0AH  ;'10' 10
            DB      1EH,00H,0AH  ;'J_' 10
            DB      2FH,00H,0AH  ;'Q_' 10
            DB      75H,00H,0AH  ;'K_' 10
            DB      77H,00H,0BH  ;'A_' 11
            DB      00H,00H,00H  ;Fill
            DB      00H,00H,00H  ;Fill

;------------
; Master Mind
;------------
MASTERMIND:
            LD      BC,0000H   ;Load BC with zero random number calculator
MM_SETUP:               
            ;Generate a random 2 byte number for the mastermind answer
            INC     BC         ;Increase BC
            LD      A,R        ;Save R register to A
            ADD     A,B        ;Add B to A
            ADC     A,C        ;Add C to A
            ADD     A,B        ;Add B to A again
            ADD     A,C        ;Add C to A again
            RLCA               ;Rotate A left
            LD      D,A        ;Save A into D
            LD      A,C        ;Load C to A 
            AND     1FH        ;Check if Bits 0-4 are set
            JR      NZ,MM_SKIP1 ;No, Skip output
            LD      A,D        ;Reload A with actual value to output
            OUT     (02),A     ;Display value of A
MM_SKIP1:   IN      A,(01)     ;Read input latch
            CP      BTN_A      ;Has button A been pressed?
            JR      NZ,MM_SETUP ;Yes, set up game data

            ;Save random number in SP
            LD      A,D        ;Restore A
            DAA                ;Fix to remove A-F
            LD      H,A        ;Save in H
            CPL                ;Invert bits to mix up number
            DAA                ;Fix to remove A-F
            LD      L,A        ;Svae in L
            LD      SP,HL      ;Save in HL

            ;Setup is complete start game loop
MM_GAME:
            ;Output '--' on the seven segment displays to indicate a new round
            LD      B,0FFH     ;Load B with long delay
MM_LOOP1:
            LD      A,40H      ;Load A with RH middle segment
            OUT     (02),A     ;Output to RH segment
            LD      A,0C0H     ;Load A with LH middle segment
            OUT     (02),A     ;Output to LH segment
            DJNZ    MM_LOOP1   ;Repeat B times

            ;Initialize counters
            XOR     A          ;Zero A
            LD      I,A        ;Reset counters and store in I
            LD      DE,0000H   ;Clear DE for player keys
            LD      C,04H      ;Counter for number of values to key
NEXTKEY:
            ;Select HEX value.  Use Button A to cycle through numbers
            ;Button B to select
            LD      IY,MM_SEGTBL ;Load IY with start of segment table starting at 0
            LD      L,00H      ;Load index L with 1
MM_DISPLAY:
            ;Display next hex value on seven segment display
            LD      A,(IY+0)   ;Load segment value at IY to A
            OUT     (02),A     ;Output the RH segment
KEYPRESS:
            ;Check for key press
            IN      A,(01)     ;Read input latch
            CP      BTN_B      ;Has button B been pressed?
            JR      Z,KEYSEL   ;Yes, Jump to key selection
            CP      BTN_A      ;Has button A been pressed?
            JR      NZ,KEYPRESS ;No, Repeat key press loop
MM_LOOP3:
            IN      A,(01)     ;Read input latch
            CP      BTN_A      ;Is button A still pressed?
            JR      Z,MM_LOOP3 ;Yes, loop until released
NEXTVAL:
            ;Button A pressed. Check if lookup table overflow
            DJNZ    NEXTVAL    ;Delay
            INC     IY         ;Move IY to next segment in table
            INC     L          ;Increase segment index
            LD      A,L        ;Load segment index to A
            DAA                ;Wrap back to zero if passed 9
            AND     0FH        ;Mask off upper nibble to keep to single digit
            JR      Z,NEXTKEY  ;Overflow, reset table index
            LD      L,A        ;Save back to L
            JR      MM_DISPLAY ;Display the next character

            ;A character has been selected with button B, handle it
KEYSEL:
            LD      A,L        ;Load A with segment index
            ;Shift value into DE from the right
            OR      E          ;Add E to A. Lower nibble is always 0
            LD      E,A        ;Update E
            LD      A,C        ;Check if on last number
            DEC     A          ;Check for zero
            JR      Z,MM_LOOP6 ;Skip shift if on last character     
            LD      B,04H      ;Shift four times
MM_LOOP5:
            SLA     E          ;Shift E left by one, set carry flag with bit 7
            RL      D          ;Shift D left by one, set bit 0 with carry flag
            DJNZ    MM_LOOP5   ;Repeat 4 times
            ;Wait if button B is still pressed
MM_LOOP6:
            IN      A,(01)     ;Read input latch
            CP      BTN_B      ;Is button B still pressed?
            JR      Z,MM_LOOP6 ;Yes, loop until released

            ;Display a pattern to show a value has been selected
            LD      B,08H      ;Count of segments in lookup table
            LD      HL,ANIMATE ;Load HL to base of animate table
LOOPANI:
            LD      A,(HL)     ;Load Segment
            OUT     (02),A     ;Output to RH segment
            EXX                ;Save registers
            LD      B,0FFH     ;Full delay
MM_DELAY:   DJNZ    MM_DELAY   ;Delay
            EXX                ;Restore registers
            INC     HL         ;Move to next segment
            DJNZ    LOOPANI    ;Display next segment

            ;Have all four values been keyed?
            DEC     C          ;Decrease value keyed counter
            JR      NZ,NEXTKEY ;More to key? Ask for next key

            ;Check keyed values in DE with actual values in SP
            LD      HL,0000H   ;Clear HL
            ADD     HL,SP      ;Load SP into HL so it can be used
            
            ;Cycle through all values in DE and HL, check for matching values in the
            ;correct spot
            LD      B,04H      ;Loop 4 times to check each value
CORRECT:
            LD      A,E        ;Load E in A to mask
            AND     0FH        ;Mask out upper nibble
            LD      C,A        ;Save in C
            LD      A,L        ;Load L in A to mask
            AND     0FH        ;Mask out upper nibble
            CP      C          ;Are they the same?
            JR      NZ,WRONG1  ;No, Skip updating score
            ;Exact Match, Update tally
            LD      A,I        ;Load counter to A
            ADD     A,01H      ;Add one
            LD      I,A        ;Save it back
            ;Rotate DE,HL bits four times to find the next value
WRONG1:
            LD      C,04H      ;Loop four times
MM_LOOP7:
            SLA     H          ;Shift left one with bit 7 in carry 
            RL      L          ;Rotate left one with bit 1 set with carry
            JR      NC,MM_SKIP2 ;If no carry then don't update H
            INC     H          ;Add one as carry is set
MM_SKIP2:
            SLA     D          ;Shift left one with bit 7 in carry 
            RL      E          ;Rotate left one with bit 1 set with carry
            JR      NC,MM_SKIP3 ;If no carry then don't update D
            INC     D          ;Add one as carry is set
MM_SKIP3:
            DEC     C          ;Decrease counter
            JR      NZ,MM_LOOP7 ;Repeat if not zero
            DJNZ    CORRECT      ;Check the next value

            ;Cycle through all values in DE and HL, check for matching values in the
            ;incorrect spot
            EXX                ;Out of counters, use shaddow
            LD      B,04H      ;Loop through all 4 keyed values
INCORRECT:
            EXX                ;Swap back
            LD      B,03H      ;Loop four time to check values
NEXTHL:
            LD      C,04H      ;Loop four times
ROTHL:
            SLA     H          ;Shift left one with bit 7 in carry 
            RL      L          ;Rotate left one with bit 1 set with carry
            JR      NC,SKIPH   ;If no carry then don't update H
            INC     H          ;Add one as carry is set
SKIPH:            
            DEC     C          ;Decrease counter
            JR      NZ,ROTHL   ;Repeat if not zero
            ;Compare lower nibbles of HL and DE
            LD      A,E        ;Load E in A to mask
            AND     0FH        ;Mask out upper nibble
            LD      C,A        ;Save in C
            LD      A,L        ;Load L in A to mask
            AND     0FH        ;Mask out upper nibble
            CP      C          ;Are they the same?
            JR      NZ,WRONG2  ;No, Skip updating score
            ;Incorrect Match, Update tally
            LD      A,I        ;Load counter to A
            ADD     A,10H      ;Add 10 hex
            LD      I,A        ;Save it back
            ;Rotate DE
WRONG2:
            DJNZ    NEXTHL
            ;Rotate DE right to get the next value
            LD      B,04H      ;Do 4 times
ROTDE:
            SRL     D          ;Shift right one with bit 0 in carry 
            RR      E          ;Rotate left one with bit 1 set with carry
            JR      NC,SKIPD   ;If no carry then don't update D
            SET     7,D        ;Set bit 7 to account for carry flag
SKIPD:
            DJNZ    ROTDE      ;Repeat until done
            ;Do outer loop
            EXX                ;Get Shaddow B
            DJNZ    INCORRECT  ;Do again until all values are checked

            EXX                ;Reset registers.

            ;All values have been checked.  Display match score. Display from first
            ;keyed value to last, one at a time.
DISPLOOP:
            ;Display keyed values and match score loop
            DJNZ    DISPLOOP   ;Delay
MM_LOOP8:   DJNZ    MM_LOOP8   ;Delay
            LD      C,04H      ;Load C with digits to display
VALUE:
            ;Rotate DE to get next value
            LD      B,04H      ;Four bits to rotate
MM_LOOP9:
            SLA     D          ;Shift left one with bit 7 in carry 
            RL      E          ;Rotate left one with bit 1 set with carry
            JR      NC,MM_SKIP4 ;If no carry then don't update D
            INC     D          ;Add one as carry is set
MM_SKIP4:            
            DJNZ    MM_LOOP9   ;Repeat until done

            ;Do the Seven Segment lookup
            LD      HL,MM_SEGTBL ;Load HL with segment Lookup table
            LD      A,E        ;Load E in A to mask
            AND     0FH        ;Mask out upper nibble
            ADD     A,L        ;Add index to key
            LD      L,A        ;Load new index back to L
            LD      A,(HL)     ;Load A with segment value
            OUT     (02),A     ;Output keyed value t0 RH segment
MM_LOOP10:  DJNZ    MM_LOOP10  ;Delay
MM_LOOP11:  DJNZ    MM_LOOP11  ;Delay
MM_LOOP12:  DJNZ    MM_LOOP12  ;Delay
MM_LOOP13:
            XOR     A          ;Zero A
            OUT     (02),A     ;Blank Segments
            DJNZ    MM_LOOP13  ;Loop to keep blank
 
            DEC     C          ;Decrease C
            JR      NZ,VALUE   ;Display next value

            ;Display correct/incorrect position count
            XOR     A          ;Zero A
            OUT     (02),A     ;Blank Segments
MM_LOOP14:  DJNZ    MM_LOOP14  ;Delay
MM_LOOP15:  DJNZ    MM_LOOP15  ;Delay
POSTYP:
            LD      C,02H      ;Load C with position type counter
MM_LOOP16:
            LD      HL,MM_SEGTBL ;Load HL with segment Lookup table
            LD      A,I        ;Load A Counter
            AND     0FH        ;Mask out upper nibble
            ADD     A,L        ;Add L to A
            LD      L,A        ;Load new index back to L
            LD      A,(HL)     ;Load A with segment value
            SET     7,A        ;Set Bit 7 on A to display on LH segment
            OUT     (02),A     ;Output correct position count to LH segment
            LD      HL,MM_SEGTBL ;Load HL with segment Lookup table
            LD      A,I        ;Load A Counter
            SRL     A          ;Shift right 1
            SRL     A          ;Shift right 1
            SRL     A          ;Shift right 1
            SRL     A          ;Shift right 1
            ADD     A,L        ;Add L to A
            LD      L,A        ;Load new index back to L
            LD      A,(HL)     ;Load A with segment value
            OUT     (02),A     ;Output incorrect position count to RH segment
            ;Check input for next game choice
            IN      A,(01)     ;Read input latch
            CP      BTN_A      ;Has button A been pressed?
            JP      Z,MM_GAME  ;Yes, restart for next round
            CP      BTN_BOTH   ;Are both buttons pressed?
            JR      Z,GIVEUP   ;Yes, display actually values and give up!
            DEC     C          ;Decrease C to display next position count
            JR      NZ,MM_LOOP16 ;Not Zero, display position count again
            DJNZ    POSTYP     ;Repeat display unilt B = 0
            XOR     A          ;Zero A
            OUT     (02),A     ;Blank Segments
            JR      DISPLOOP   ;Re display position count
GIVEUP:
            ;Bit 0 set, so give up and display actual sequence
            LD      HL,0000H    ;Load HL with 0
            ADD     HL,SP       ;Get real values from SP to HL
            EX      DE,HL       ;Store HL in DE
            JR      DISPLOOP    ;Jump to Display loop to show actual sequence
            
            ;Ascii character table for seven segment display
MM_SEGTBL:  DB      3FH,06H,5BH,4FH,66H,6DH,7DH,07H,7FH,67H  ;0-9
ANIMATE:    DB      01H,02H,04H,08H,88H,90H,0A0H,81H         ;Animation sequence

;----
; NIM
;----
NIM:              
            ;Set up
            LD      A,23H      ;Load A with initical start value
            LD      I,A        ;Save A in the index register to store game count
            LD      C,00H      ;C is used to to determine the active player and button
            LD      E,03H      ;Load E with max matches per player turn
N_GAME:
            ;Start of game loop            
            LD      D,20H      ;Load D with 32 for long thinking delay if computer plays
ROUND:
            ;Display Right Segment
            LD      HL,N_SEGTBL ;Load HL with Segment Data Table
            LD      A,I        ;Load A with current game value
            AND     0FH        ;Mask off upper nibble
            ADD     A,L        ;Index L with A
            LD      L,A        ;Index Segment table with A
            LD      A,(HL)     ;Load Segment Value to A
            OUT     (02),A     ;Output segment value to RH display
            LD      B,10H      ;Load B with short delay
N_LOOP1:    DJNZ    N_LOOP1    ;Delay
            
            BIT     3,C        ;Is Bit 3 set?
            JR      Z,BUTCHK   ;No, Players turn
         
            XOR     A          ;Zero A
            LD      B,30H      ;Load B with short delay
N_LOOP2:    DJNZ    N_LOOP2    ;Delay
            JR      DISLEFT    ;Display Left Value
BUTCHK:
            ;Check if button pressed
            IN      A,(01)     ;Read input latch
            CP      BTN_A      ;Has Button 'A' been pressed?
            JR      Z,BUTTONA  ;Yes, handle Button A press
            RES     0,C        ;Reset Bit 0 as button A not pressed
            CP      BTN_B      ;Has Button 'B' been pressed?
            JR      Z,BUTTONB  ;Yes, handle Button B press
DISLEFT:
            ;Display Left Segment
            LD      A,I        ;Load A with current game value
            RRA                ;Swap upper
            RRA                ;nibble with
            RRA                ;lower nibble
            RRA                ;
            AND     0FH        ;Mask off upper nibble
            LD      HL,N_SEGTBL ;Load HL with Segment Data Table
            ADD     A,L        ;Index L with A
            LD      L,A        ;Index Segment table with A
            LD      A,(HL)     ;Load Segment Value to A
            SET     7,A        ;Set Bit 7 to display on LH display
            OUT     (02),A     ;Output segment value to LH display
            LD      B,10H      ;Load B with short delay
N_LOOP3:    DJNZ    N_LOOP3    ;Delay

            BIT     3,C        ;Is Bit 3 set?
            JR      Z,GAMECHK  ;No, Players turn
            
            XOR     A          ;Zero A
            LD      B,30H      ;Load B with short delay
N_LOOP4:    DJNZ    N_LOOP4    ;Delay

GAMECHK:
            ;Check game state
            DEC     D          ;Decrease D
            JP      NZ,ROUND   ;If not zero, do round again
            BIT     3,C        ;Is Bit 3 set? Is computer playing?
            JP      Z,N_GAME   ;No, Repeast Game loop
            JR      COMPTURN   ;Yes, handle computer game turn
BUTTONA:
            ;Button 'A' press handler
            BIT     0,C        ;Is bit Zero set?
            JR      NZ,DISLEFT ;Yes, display Left segment
            SET     0,C        ;Set bit zero to indicate button 'a' press mode
            LD      A,I        ;Load current game count in A
            DEC     A          ;Reduce count by one
            DAA                ;Adjust for hex to decimal
            CP      00H        ;Is score zero?
            JR      Z,LOSE     ;Yes, player loses
            LD      I,A        ;Store new game count back in I
            DEC     E          ;Decrease player match pick up left
            JR      Z,BUTTONB  ;If all used up, start computer turn
            JP      ROUND      ;Handle next round
BUTTONB:
            ;Button 'B' press handler
            SET     3,C        ;Set bit 3 for computer turn
            LD      A,I        ;Load current game count to A
            CP      01H        ;Is score one?
            JR      Z,N_WIN    ;Yes, player wins
COMPLAY:
            ;Play computer. Work out what the computer value will be
            CP      05H        ;Is current game count 5 or higher?
            JR      Z,DO_DEC   ;Do computer decrease game count
            JR      C,CONTGAME ;Is score lower than 5?
            SUB     04H        ;Subtract 4 from game total
            DAA                ;Adjust for decimal
            JR      COMPLAY    ;Repeat until value under 4
CONTGAME:
            LD      E,A        ;Save computer value in E
            JP      N_GAME     ;Repeat game loop
COMPTURN:
            ;Adjust game value with computers turn
            DEC     E          ;Decrease computer value
            JR      Z,COMPDONE ;If no more to do, exit computer round
            XOR     A          ;Zero A
            OUT     (02),A     ;Blank the Segments
N_LOOP5:    DJNZ    N_LOOP5    ;Long Delay
            LD      A,I        ;Load current game value to A
            DEC     A          ;Decrease A
            DAA                ;Adjust for decimal
            LD      I,A        ;Save count back to A
            JP      N_GAME     ;Repeat Game Loop
COMPDONE:
            RES     3,C        ;Reset Bit 3 to end Computer turn
            LD      E,03H      ;Reset max matches per round
            JP      ROUND      ;Handle next round
DO_DEC:
            LD      A,R        ;Load A with Random value
N_LOOP6:
            ;Calculate computer value
            INC     A          ;Increase A to its not zero
            AND     07H        ;Mask out high nibble
            CP      05H        ;Is the value 5 or more?
            JR      NC,N_LOOP6 ;Yes, try again
            CP      02H        ;Is it under 2?
            JR      C,N_LOOP6  ;Yes, try again
            LD      E,A        ;Value is between 2 and 4, save back in E
            JP      N_GAME     ;Repeat Game Loop
LOSE:
            ;Computer wins  
            LD      B,00H      ;Load B with long delay
            LD      D,0BH      ;Load D with chracter count
            LD      HL,LOSEMSG ;Load HL with start of lose message
            LD      IY,LOSE    ;Load IY with jump return address
            JP      PRNTMSG    ;Call Print message subroutine
N_WIN:
            ;Player wins
            LD      B,00H      ;Load B with long delay
            LD      D,09H      ;Load D with charcter count
            LD      HL,WINMSG  ;Load HL with start of win message
            LD      IY,N_WIN   ;Load IY with jump return address
PRNTMSG:
            ;Cycle through character table printing one character at a time
            LD      A,(HL)     ;Load A with segment character
            OUT     (02),A     ;Output character to RH display
            LD      C,05H      ;Load C with display repeat count
N_LOOP7:    DJNZ    N_LOOP7    ;Delay
            DEC     C          ;Decrease C
            JR      NZ,N_LOOP7 ;If C is not zero repeat delay
            XOR     A          ;Zero A
            OUT     (02),A     ;Blank the Segments
            LD      B,80H      ;Load B with delay
N_LOOP8:    DJNZ    N_LOOP8    ;Delay
            INC     HL         ;Move HL to next character
            DEC     D          ;Decrease D for next char count
            JR      NZ,PRNTMSG ;Repeat display until all characters printed
            JP      (IY)       ;Return back calling routing
            NOP                ;Fill

            ;Ascii character table for seven segment display
N_SEGTBL:   DB      3FH,06H,5BH,4FH,66H,6DH,7DH,07H,7FH,67H ;0-9

            ;Win/Lose messages
LOSEMSG:    DB      00H,6EH,3FH,3EH,00H,38H,3FH,6DH,79H     ;You Lose
            DB      00H,00H

WINMSG:     DB      00H,30H,00H,38H,3FH,6DH,79H,00H,00H     ;I Lose

;----------
; Tug O War
;----------
TUGOWAR:
            ;Start up
            LD      HL,TW_SEGTBL  ;Point to start of 0-9 table for LH display
            LD      DE,TW_SEGTBL  ;Point to start of 0-9 table for RH display
            LD      C,00H      ;Load Button Debounce test flag register with zero
TW_DISPLAY:
            ;Display multiplexing
            LD      A,(DE)     ;Load A with the current digit for RH display
            OUT     (02),A     ;Output digit to RH display
            LD      B,20H      ;Load B with short delay
TW_LOOP1:   DJNZ    TW_LOOP1   ;Delay
            XOR     A          ;Zero A
            SET     7,A        ;Set Bit 7 to activate LH display
            ADD     A,(HL)     ;Add A with the current digit for LH display
            OUT     (02),A     ;Output digit to LH display
BUTTONS:
            ;Look at Buttons
            IN      A,(01)     ;Read input latch
            CP      BTN_BOTH   ;Are both buttons pressed? 40H + 80H = C0H
            JR      Z,NO_UPD   ;Yes, Don't update anything and repeat display
            CP      BTN_B      ;Has button 'B' been pressed?
            JR      Z,B_PRESS  ;Yes, Handle button 'B' pressed
            RES     0,C        ;No, Reset Button 'B' pressed flag
CHK_A: 
            IN      A,(01)     ;Read input latch
            CP      BTN_BOTH   ;Are both buttons pressed? 40H + 80H = C0H
            JR      Z,NO_UPD   ;Yes, Don't update anything and repeat display
            CP      BTN_A      ;Has button 'A' been pressed?
            JR      Z,A_PRESS  ;Yes, Handle button 'B' pressed
            RES     1,C        ;No, Reset Button 'A' pressed flag
NO_UPD:
            ;Repeat Display
            LD      B,10H      ;Load B with short delay
TW_LOOP2:   DJNZ    TW_LOOP2   ;Delay
            JR      TW_DISPLAY ;Jump back to display routine
B_PRESS:
            ;Button 'B' pressed
            BIT     0,C        ;Has button 'B' already been pressed?
            JR      NZ,CHK_A   ;Yes, check button 'A'
            SET     0,C        ;Set button 'B' pressed flag
            INC     DE         ;Move current digit for RH closer to 9
            LD      A,(DE)     ;Load A with the next digit for RH display
            CP      67H        ;Is it 9? 
            JR      NZ,DEC_A   ;No, Jump to Decrease LH player
            ;Player B wins
DIS_WIN_B:                     ;Flash RH display
            LD      C,10H      ;Load C with multiplex delay
TW_LOOP3:
            LD      A,(DE)     ;Load A with the current digit for RH display
            OUT     (02),A     ;Output digit to RH display
            LD      B,10H      ;Load B with short delay
TW_LOOP4:   DJNZ    TW_LOOP4   ;Delay
            XOR     A          ;Zero A
            SET     7,A        ;Set Bit 7 to activate LH display
            ADD     A,(HL)     ;Add A with the current digit for LH display
            OUT     (02),A     ;Output digit to LH display
            LD      B,10H      ;Load B with short delay
TW_LOOP5:   DJNZ    TW_LOOP5   ;Delay
            DEC     C          ;Decrease multiplex repeater
            JR      NZ,TW_LOOP3 ;Repeat display
            LD      C,10H      ;Load C with multiplex delay
TW_LOOP6:
            XOR     A          ;Zero A
            OUT     (02),A     ;Output digit to RH display
            LD      B,10H      ;Load B with short delay
TW_LOOP7:   DJNZ    TW_LOOP7   ;Delay
            XOR     A          ;Zero A
            SET     7,A        ;Set Bit 7 to activate LH display
            ADD     A,(HL)     ;Add A with the current digit for LH display
            OUT     (02),A     ;Output digit to LH display
            LD      B,10H      ;Load B with short delay
TW_LOOP8:   DJNZ    TW_LOOP8   ;Delay
            DEC     C          ;Decrease multiplex repeater
            JR      NZ,TW_LOOP6 ;Repeat display
            JR      DIS_WIN_B  ;Keep Flashing Screen forever!
DEC_A:
            ;Decrease LH Player digit
            LD      A,(HL)     ;Add A with the current digit for LH display
            CP      3FH        ;Is it Zero?
            JR      NZ,DO_DEC_A ;No, Do Decrease
            JR      BUTTONS    ;Yes, Just check buttons again and display
DO_DEC_A:
            DEC     HL         ;Move LH Player back one digit
            JR      BUTTONS    ;Check buttons again and display
A_PRESS:
            ;Button 'A' pressed
            BIT     1,C        ;Has button 'A' already been pressed?
            JR      NZ,NO_UPD  ;Yes, Don't update anything and repeat display
            SET     1,C        ;Set button 'A' pressed flag
            INC     HL         ;Move current digit for LH closer to 9
            LD      A,(HL)     ;Load A with the next digit for LH display
            CP      67H        ;Is it 9? 
            JR      NZ,DEC_B   ;No, Jump to Decrease RH player
            ;Player A wins
DIS_WIN_A:                     ;Flash RH display
            LD      C,10H      ;Load C with multiplex delay
TW_LOOP9:
            LD      A,(DE)     ;Load A with the current digit for RH display
            OUT     (02),A     ;Output digit to RH display
            LD      B,10H      ;Load B with short delay
TW_LOOP10:  DJNZ    TW_LOOP10  ;Delay
            XOR     A          ;Zero A
            SET     7,A        ;Set Bit 7 to activate LH display
            ADD     A,(HL)     ;Add A with the current digit for LH display
            OUT     (02),A     ;Output digit to LH display
            LD      B,10H      ;Load B with short delay
TW_LOOP11:  DJNZ    TW_LOOP11  ;Delay
            DEC     C          ;Decrease multiplex repeater
            JR      NZ,TW_LOOP9 ;Repeat display
            LD      C,10H      ;Load C with multiplex delay
TW_LOOP12:
            LD      A,(DE)     ;Load A with the current digit for RH display
            OUT     (02),A     ;Output digit to RH display
            LD      B,10H      ;Load B with short delay
TW_LOOP13:  DJNZ    TW_LOOP13  ;Delay
            XOR     A          ;Zero A
            OUT     (02),A     ;Output digit to LH display
            LD      B,10H      ;Load B with short delay
TW_LOOP14:  DJNZ    TW_LOOP14  ;Delay
            DEC     C          ;Decrease multiplex repeater
            JR      NZ,TW_LOOP12 ;Repeat display
            JR      DIS_WIN_A  ;Keep Flashing Screen forever!
DEC_B:
            ;Decrease RH Player digit
            LD      A,(DE)     ;Load A with the current digit for RH display
            CP      3FH        ;Is it Zero?
            JR      NZ,DO_DEC_B ;No, Do Decrease
            JP      BUTTONS    ;Yes, Just check buttons again and display
DO_DEC_B:
            DEC     DE         ;Move RH Player back one digit
            JP      BUTTONS    ;Check buttons again and display

;Table that displays the numbers 0-9.  Numbers repeat more as they get closer to 9
TW_SEGTBL:  DB      3FH,06H,06H,5BH,5BH,5BH,4FH,4FH  ;01122233
            DB      4FH,4FH,66H,66H,66H,66H,66H,6DH  ;33444445
            DB      6DH,6DH,6DH,6DH,6DH,7DH,7DH,7DH  ;55555666
            DB      7DH,7DH,7DH,7DH,07H,07H,07H,07H  ;66667777
            DB      07H,07H,07H,07H,7FH,7FH,7FH,7FH  ;77778888
            DB      7FH,7FH,7FH,7FH,7FH,67H          ;888889
;Fill
            DB      00H,00H,00H,00H,00H,00H,00H,00H

;---------
; LED Demo
;---------
LEDDEMO:
            LD      IY,DATA_TBL ;Point IY to start of data table

OD_DISPLAY: 
            LD      L,(IY+00H)  ;Load L
            LD      H,(IY+01H)  ;Load H
            INC     IY          ;Move to next data location
            INC     IY          ;
            ;Check for zero
            LD      A,H         ;Load A with H
            OR      L           ;Compare with L
            JR      NZ,$+3      ;Not zero do display
            ;Exit
            RST     00H         ;Restart Program

            LD      C,(IY+00H)  ;Load loop counter
            INC     IY          ;Move to next data location
            LD      IX,$+6      ;Next routines
            JR      LEDSEQ      ;Display Routine

            LD      L,(IY+00H)  ;Load L
            LD      H,(IY+01H)  ;Load H
            INC     IY          ;Move to next data location
            INC     IY          ;
            LD      C,(IY+00H)  ;Load loop counter
            INC     IY          ;Move to next data location

            LD      IX,OD_DISPLAY ;Next routines
            JR      LEDMUX      ;Display Routine

;Output Directly to the LED's with sequential data
; IN - HL - data to send, FF to end
; Exit to address pointing to IX
LEDSEQ:
            LD      SP,HL      ;Save HL for looping
OD_LOOP1:
            LD      A,(HL)     ;Load Data
            CP      0FFH       ;Is it end of sequence
            JR      Z,ENDSEQ   ;Yes, Exit the routine
            OUT     (02),A     ;Send to Output latch
            LD      B,0FFH     ;Full delay
LEDDLY:     DJNZ    LEDDLY     ;Delay
            INC     HL         ;Move to next segment
            JR      OD_LOOP1   ;Display next segment
ENDSEQ: 
            LD      HL,0000H   ;Wipe HL
            ADD     HL,SP      ;Restore HL
            DEC     C          ;Decrease loop counter
            JR      NZ,OD_LOOP1 ;Repeat sequence
            JP      (IX)       ;Jump back to calling routine


;Multiplex the 4x4 LED's
; IN - HL - data to send (in groups of 4, one byte per column), FF to end
; Exit to address pointing to IX
LEDMUX:
            LD      SP,HL      ;Save HL for looping
OD_LOOP2:
            LD      A,(HL)     ;Load Segment data
            CP      0FFH       ;Is it end of sequence
            JR      Z,ENDMUX   ;Yes, Exit the routine
            LD      B,040H     ;Half Delay
MUXLOOP:
            LD      D,04H      ;Four columns
MUXOUT: 
            LD      A,(HL)     ;Load Segment data
            OUT     (02),A     ;Output to 4x4 LED
            INC     HL         ;Move to next column
            DEC     D          ;One less column
            JR      NZ,MUXOUT  ;Display next column
            LD      A,B        ;Load B to A
            SUB     01H        ;Is it on the last run, skip roll back
            JR      Z,MUXSKIP  ;Skip roll back as on last display loop
            DEC     HL         ;Roll back HL
            DEC     HL         ;Roll back HL
            DEC     HL         ;Roll back HL
            DEC     HL         ;Roll back HL
MUXSKIP:
            DJNZ    MUXLOOP    ;Do 4x4 loop again FF times
            JR      OD_LOOP2     ;Repeat until FF
ENDMUX:
            LD      HL,0000H   ;Wipe HL
            ADD     HL,SP      ;Restore HL
            DEC     C          ;Decrease loop counter
            JR      NZ,OD_LOOP2 ;Repeat sequence
            JP      (IX)       ;Jump back to calling routine

;Data table lookup to help reduce code duplication
DATA_TBL:
            DW      OD_DATA1
            DB      08H
            DW      OD_DATA2
            DB      04H
            DW      OD_DATA3
            DB      06H
            DW      OD_DATA4
            DB      04H
            DW      OD_DATA5
            DB      02H
            DW      OD_DATA6
            DB      01H
            DW      OD_DATA7
            DB      04H
            DW      OD_DATA8
            DB      03H
            DW      OD_DATA9
            DB      04H
            DW      OD_DATA10
            DB      02H
            DW      OD_DATA11
            DB      04H
            DW      OD_DATA12
            DB      08H,00H,00H 

OD_DATA1:   DB      001H,002H,004H,008H,010H,020H,040H,080H,0FFH ;All bites
OD_DATA2:   DB      071H,0B2H,0D4H,0E8H,078H,0B4H,0D2H,0E1H,0FFH ;Diagonals
OD_DATA3:   DB      081H,001H,002H,040H,0C0H,090H,088H,008H      ;Round Segments
            DB      004H,040H,0C0H,0A0H,0FFH                     
OD_DATA4:   DB      0E1H,0C2H,084H,008H,001H,082H,0C4H,0E8H      ;Rotating Triangle
            DB      001H,012H,034H,078H,071H,032H,014H,008H,0FFH 
OD_DATA5:   DB      071H,033H,017H,00FH,08EH,0CCH,0E8H,000H      ;4 Corner Strobe
            DB      0E1H,0C3H,087H,00FH,01EH,03CH,078H,000H
            DB      0E8H,0CCH,08EH,00FH,017H,033H,071H,000H
            DB      078H,03CH,01EH,00FH,087H,0C3H,0E1H,000H,0FFH 
OD_DATA6:   DB      0F1H,0F2H,0F4H,0F8H,0F1H,0F2H,0F4H,088H      ;Microcomp Scroll
            DB      0F1H,0F2H,084H,078H,0F1H,082H,074H,088H
            DB      081H,072H,084H,078H,071H,082H,074H,088H
            DB      081H,072H,084H,0F8H,071H,082H,0F4H,048H
            DB      081H,0F2H,044H,0F8H,0F1H,042H,0F4H,098H
            DB      041H,0F2H,094H,068H,0F1H,092H,064H,068H
            DB      091H,062H,064H,0F8H,061H,062H,0F4H,088H
            DB      061H,0F2H,084H,078H,0F1H,082H,074H,078H
            DB      081H,072H,074H,0F8H,071H,072H,0F4H,098H
            DB      071H,0F2H,094H,068H,0F1H,092H,064H,068H
            DB      091H,062H,064H,098H,061H,062H,094H,0F8H
            DB      061H,092H,0F4H,098H,091H,0F2H,094H,068H
            DB      0F1H,092H,064H,068H,091H,062H,064H,0F8H
            DB      061H,062H,0F4H,098H,061H,0F2H,094H,068H
            DB      0F1H,092H,064H,068H,091H,062H,064H,098H
            DB      061H,062H,094H,0F8H,061H,092H,0F4H,088H
            DB      091H,0F2H,084H,078H,0F1H,082H,074H,088H
            DB      081H,072H,084H,078H,071H,082H,074H,088H
            DB      081H,072H,084H,0F8H,071H,082H,0F4H,008H
            DB      081H,0F2H,004H,058H,0F1H,002H,054H,018H
            DB      001H,052H,014H,0F8H,051H,012H,0F4H,0F8H
            DB      011H,0F2H,0F4H,0F8H,0F1H,0F2H,0F4H,0F8H,0FFH 
OD_DATA7:   DB      071H,072H,074H,078H,0B8H,0B4H,0B2H,0B1H      ;Zig Zag
            DB      0D1H,0D2H,0D4H,0D8H,0E8H,0E4H,0E2H,0D1H
            DB      0B1H,071H,072H,0B2H,0D2H,0E2H,0E4H,0D4H
            DB      0B4H,074H,078H,0B8H,0D8H,0E8H,0E4H,0E2H
            DB      0E1H,0D1H,0B1H,0FFH                          
OD_DATA8:   DB      071H,092H,094H,0E8H,0F1H,012H,084H,0F8H      ;Propeller
            DB      0F1H,082H,014H,0F8H,0E1H,092H,094H,078H
            DB      0D1H,092H,094H,0B8H,0B1H,092H,094H,0D8H,0FFH 
OD_DATA9:   DB      071H,078H,0E8H,0E1H,033H,03CH,0CCH,0C3H      ;Square Circle
            DB      017H,01EH,08EH,087H,00FH,00FH,00FH,00FH
            DB      017H,01EH,08EH,087H,033H,03CH,0CCH,0C3H
            DB      071H,078H,0E8H,0E1H,0FFH                     
OD_DATA10:  DB      0C1H,0E2H,0E4H,0E8H,0C1H,0E2H,0E4H,0C8H      ;Running Man
            DB      0E1H,0A2H,0C4H,0E8H,0E1H,0C2H,064H,0E8H
            DB      0C1H,0E2H,0A4H,0E8H,0E1H,0C2H,0E4H,0E8H
            DB      0C1H,0E2H,0E4H,0E8H,0C1H,0E2H,0E4H,088H
            DB      0E1H,0A2H,084H,0E8H,0E1H,082H,064H,0E8H
            DB      081H,0E2H,0A4H,0E8H,0E1H,0C2H,0E4H,0E8H
            DB      0C1H,0E2H,0E4H,0E8H,0C1H,0E2H,0E4H,008H
            DB      0E1H,0A2H,004H,0E8H,061H,002H,0E4H,0E8H
            DB      0A1H,002H,0E4H,0E8H,0C1H,002H,0E4H,0E8H
            DB      0C1H,022H,0E4H,0E8H,001H,0E2H,0E4H,0E8H
            DB      021H,0C2H,0E4H,0E8H,0E1H,0C2H,0E4H,0E8H
            DB      0C1H,0E2H,0E4H,0E8H,0C1H,0E2H,0E4H,0F8H
            DB      0C1H,0E2H,0F4H,0E8H,0C1H,0F2H,0E4H,0E8H
            DB      0E1H,0D2H,0E4H,0E8H,0E1H,0E2H,0E4H,0E8H
            DB      0D1H,0E2H,0D4H,0D8H,0B1H,0E2H,0B4H,0B8H
            DB      071H,0E2H,074H,078H,0F1H,0E2H,0F4H,0F8H
            DB      0F1H,0D2H,0F4H,0F8H,0F1H,0B2H,0F4H,0F8H
            DB      0F1H,072H,0F4H,0F8H,0E1H,062H,0E4H,0E8H
            DB      0E1H,0A2H,0E4H,0E8H,0E1H,0C2H,0E4H,0E8H
            DB      0E1H,0C2H,0E4H,0E8H,0C1H,0E2H,0E4H,0E8H,0FFH
OD_DATA11:  DB      07FH,0BFH,0DFH,0EFH,001H,002H,004H,008H
            DB      0EFH,0DFH,0BFH,07FH,008H,004H,002H,001H,0FFH
OD_DATA12:  DB      0F1H,092H,094H,0F8H,001H,062H,064H,008H
            DB      0F1H,092H,094H,0F8H,091H,062H,064H,098H
            DB      061H,0F2H,0F4H,068H,0FFH,000H,000H,000H

;===============
; End of Listing
;===============

